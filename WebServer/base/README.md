# 基础工具类 
 
## noncoptable 

原理：如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是**被删除的函数**或者**不可访问**，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作 

代码中第一种是将基类的拷贝构造函数、拷贝赋值运算符是**被删除的函数** 
boost库中的是将拷贝构造函数、拷贝赋值运算符修饰成**不可访问** 

## Mutex 

封装底层原语时，尽量只使用非递归的互斥器和条件变量，慎用读写锁，不要用信号量 

将Mutex用RAII手法封装，这样可以避免用户加锁后未解锁就释放掉当前作用域而导致死锁，即MutexLockGuard类 

## Condition 

封装条件变量的基本用法 

利用timespec结构体来保存时间 

clock_gettime将当前系统时间放入timespec变量中 

加上需要等待的时间，放入pthread_cond_timedwait即可 

## CurrentThread 

与当前线程相关的一些变量和函数

*   __thread
    1.  __thread是GCC内置的线程局部存储设施
    2.  只能修饰POD类型(类似整型指针的标量，不带自定义的构造、拷贝、赋值、析构的类型，二进制内容可以任意复制memset,memcpy,且内容可以复原).
    3. 不能修饰class类型，因为无法自动调用构造函数和析构函数.
    4. 可以用于修饰全局变量，函数内的静态变量，不能修饰函数的局部变量或者class的普通成员变量，且__thread变量值只能初始化为编译器常量.
 
__builtin_expect(long exp, long c)
* 帮助程序员处理分支预测
* 你期望 exp 表达式的值等于常量 c, 看 c 的值, 如果 c 的值为0(即期望的函数返回值), 那么 执行 if 分支的的可能性小, 否则执行 else 分支的可能性小(函数的返回值等于第一个参数 exp). 

## Thread 

将pthread相关操作封装成Thread类，实现CurrentThread空间中的函数 

其中，回调函数利用std::function来包装
* std::function可以包装任何类型的可调用实体，如普通函数、函数对象、lambda表达式等 
* 包装器类型仅依赖于调用特征，而不依赖于可调用元素自身的类型 

* ::syscall()
    * 作用域符号前面什么都不写，代表全局函数 

1. 首先Thread构造出一个只含有标志位和线程名称的线程操作对象 
2. 其次start()创建出一个子线程进行工作，其中ThreadData结构体用于保存线程相关数据，如线程工作函数、线程ID、线程名称、持有的倒计时锁等，线程创建中的函数指针仅用于开启ThreadData中的真正工作函数 
3. 如果当前线程没有调用pthread_join，则将子线程分离出去，独立进行工作，否则就阻塞等待回收 

## Log 

异步日志系统 

主要思路仿照muduo库的log日志系统的设计 

与Log相关的类有5个，其中前4个类都有一个append函数，Log的设计也是围绕append函数展开： 

* **FileUtil**，封装了Log文件的打开、写入并在析构时关闭文件，底层使用标准IO，通过append函数直接向文件写  

* **LogFile**，进一步封装FileUitl，并设置一个循环次数，循环定时flush  

* **AsyncLogging**，日志系统的核心，负责启动一个log线程，专门用于将log写入LogFile（定时写入或被填满时），应用了 **“双缓冲技术”**，实际用了4个缓冲区  
    * 双缓冲技术基本思想：准备两块buffer：A和B，前端往A填数据，后端负责将B的数据写入文件，当A写满之后，交换A和B，让后端将A的数据写入文件，而前端则往B填入新的日志消息。即便A未满，日志库也会每3秒执行一次交换操作  

* **LogStream**，主要用于格式化输出，重载<<运算符，同时本身拥有一块缓冲区，这里缓冲区的存在是为了缓存一行，把多个<<的结果连成一块  

* **Logging**，对外接口，其中内含一个LogStream对象，主要是为了每次打印log时在log前和后加上固定的格式化信息，比如打印log的行、文件名等信息